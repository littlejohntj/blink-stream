# Blink Stream

### Doc Ideas
- How to set this up for yourself
- How it works
- Code info
- Config stuff like env

## Todo

### Need to have
- Outline the full set up flow
- Make the apis for the front end permissioned

### Nice to have
- Message filtering
- Build in "levels of confusing" modes ie. Just message + Send $1 vs.  All the tokens appearing
- Let streamers set their donation amount and token
- Let streamer pick a token to receive
- Add token swaps from the sender token to the receiver token
- See if we should be sending a donation post request instead of an alert

### Bugs
- Double notifactions when running locally since were using the same pubkeys for mainnet and local
- Fails on sol transfers since there is no tokenTransfers struct in the helius response
- Streamer name text does not render on production for the streamer image

### Branding Todos
- Make an info page
- New favicon
- Custom gif
- Add a real domain name


### Setting Up Helius

1. Run the script with the command `npm run pubkey` to generate a new pubkey to use for Helius Webhooks
2. Add this pubkey as the HELIUS_WEBHOOK_PUBKEY var in your .env file
3. Add a secret string you come up with as the HELIUS_AUTH_HEADER var in your .env file
3. Go to the [Helius](https://www.helius.dev/) website and create an account
4. Go to the webhooks section of the developer portal
5. Create a new webhook with the following settings
- Network: Mainnet
- Webhook Type: Enhanced
- Transaction Type: Any
- Webhook Url: <url from ngrok>/api/helius
- Authentication Header: string from your .local.env file
- Account Address: Pubkey from your .local.env file
6. Go to your RPCs and copy the mainnet rpc url and add this as the RPC_URL var in your .env file

## Docs Outline
- Register w/ Streamlabs
- Setting Up Helius
- Setting Up Database
- How to Works ( Sequence Diagrams )
- Env File
- Video Demo

# Auth Progress
Ok so i think I have an idea of what the auth flow is gonna be. First thing I want to do here
is write out my thoughts of the flow and how its gonna work. Then I should document this with some kind of sequenece diagram to prove 
out the model.

So were gonna start by updating to just tiplink wallet on the frontend. This was it's the only wallet we support.
Then were gonna use their auto signing on connect wallet. This should give us a signed message we can use to verify identity. 
Were also going to need to switch up how we look for this token on page load and use that to decide what we render. State bout to 
get crazyyyyyyy.

But yeah, so were gonna use tiplink auto sign on connect to get a signed message to verify. We can probably just make sure its some length old or something idk. 

Then we have the issue of the requests from frontend to backend. Then we have the issue of streamlabs.

For frontend to backend, the frontend will need to send the most recent signed message. We will use this on all requests and verify it
to do anything. 


For streamlabs, we need to use this without doxing to streamlabs a signed message, cause thats insecure. So we will use that signed message 
with a new request. That new request will use that to get some kind of value generated by the backend. That generated value is created via auth. So its safe, and it cant be used for anything else expect for getting an access token and saving it for the user. 

I dont know exactly what all these things are gonna be but if I stick with just only allowing the last signed message, and then use that to hash everything we should be chillin.

Ok so i want to break this up so were not building flows but were building a system.

One system is the thing to connect and get a signed message. That signed message will then get saved in local storage and can be used again later.

If that signed message is used, and then is determined to be bad, it should return a response that will get the user to a 'signed out' state.

So we then turn our "connect" into a "sign in" and "sign out" then sign out should also just delete the local token. 

We can also add a helper there to ask the backend to delete that last token.

### Auth Flows
- Sign out flow ( how the user goes from signed in to signed out )
- Sign in flow ( how the user goes from signed out locally to signed in )
- Frontend -> Backend request flow ( how the frontend makes requests to the backend to modify state )
- Streamlabs auth flow ( how the user goes and gets a stream labs acess token )
- On page load flow ( determins if the user is log in and what state to show )

What order does it make sense to do this in? Technically these flows should be independant of each other, but we should do ourselves the favor of making it all make sense.

1. Sign in
2. Sign out
3. On page load
4. Frontend -> Backend
5. Streamlabs

