# Blink Stream

### Doc Ideas
- How to set this up for yourself
- How it works
- Code info
- Config stuff like env

## Todo

### Need to have
- Outline the full set up flow
- Make the apis for the front end permissioned

### Nice to have
- Message filtering
- Build in "levels of confusing" modes ie. Just message + Send $1 vs.  All the tokens appearing
- Let streamers set their donation amount and token
- Let streamer pick a token to receive
- Add token swaps from the sender token to the receiver token
- See if we should be sending a donation post request instead of an alert

### Bugs
- Double notifactions when running locally since were using the same pubkeys for mainnet and local
- Fails on sol transfers since there is no tokenTransfers struct in the helius response
- Streamer name text does not render on production for the streamer image

### Branding Todos
- Make an info page
- New favicon
- Custom gif
- Add a real domain name


### Setting Up Helius

1. Run the script with the command `npm run pubkey` to generate a new pubkey to use for Helius Webhooks
2. Add this pubkey as the HELIUS_WEBHOOK_PUBKEY var in your .env file
3. Add a secret string you come up with as the HELIUS_AUTH_HEADER var in your .env file
3. Go to the [Helius](https://www.helius.dev/) website and create an account
4. Go to the webhooks section of the developer portal
5. Create a new webhook with the following settings
- Network: Mainnet
- Webhook Type: Enhanced
- Transaction Type: Any
- Webhook Url: <url from ngrok>/api/helius
- Authentication Header: string from your .local.env file
- Account Address: Pubkey from your .local.env file
6. Go to your RPCs and copy the mainnet rpc url and add this as the RPC_URL var in your .env file

## Docs Outline
- Register w/ Streamlabs
- Setting Up Helius
- Setting Up Database
- How to Works ( Sequence Diagrams )
- Env File
- Video Demo

# Auth Progress
Ok so i think I have an idea of what the auth flow is gonna be. First thing I want to do here
is write out my thoughts of the flow and how its gonna work. Then I should document this with some kind of sequenece diagram to prove 
out the model.

So were gonna start by updating to just tiplink wallet on the frontend. This was it's the only wallet we support.
Then were gonna use their auto signing on connect wallet. This should give us a signed message we can use to verify identity. 
Were also going to need to switch up how we look for this token on page load and use that to decide what we render. State bout to 
get crazyyyyyyy.

But yeah, so were gonna use tiplink auto sign on connect to get a signed message to verify. We can probably just make sure its some length old or something idk. 

Then we have the issue of the requests from frontend to backend. Then we have the issue of streamlabs.

For frontend to backend, the frontend will need to send the most recent signed message. We will use this on all requests and verify it
to do anything. 


For streamlabs, we need to use this without doxing to streamlabs a signed message, cause thats insecure. So we will use that signed message 
with a new request. That new request will use that to get some kind of value generated by the backend. That generated value is created via auth. So its safe, and it cant be used for anything else expect for getting an access token and saving it for the user. 

I dont know exactly what all these things are gonna be but if I stick with just only allowing the last signed message, and then use that to hash everything we should be chillin.

Ok so i want to break this up so were not building flows but were building a system.

One system is the thing to connect and get a signed message. That signed message will then get saved in local storage and can be used again later.

If that signed message is used, and then is determined to be bad, it should return a response that will get the user to a 'signed out' state.

So we then turn our "connect" into a "sign in" and "sign out" then sign out should also just delete the local token. 

We can also add a helper there to ask the backend to delete that last token.

### Auth Flows
- Sign out flow ( how the user goes from signed in to signed out )
- Sign in flow ( how the user goes from signed out locally to signed in )
- Frontend -> Backend request flow ( how the frontend makes requests to the backend to modify state )
- Streamlabs auth flow ( how the user goes and gets a stream labs acess token )
- On page load flow ( determins if the user is log in and what state to show )

What order does it make sense to do this in? Technically these flows should be independant of each other, but we should do ourselves the favor of making it all make sense.

1. Sign in
2. Sign out
3. On page load
4. Frontend -> Backend
5. Streamlabs

### Sign in / Sign Out

Ok I think i have a base here but now were gonna need to move to the next part of actually being signed in and stuff, i would kinda like there to be more of a state machine here
Right now, I guess there really is an explict sign in function, so as long as that works, we should be covered, similar to sign out
So maybe i can just go back to the page load vibe and make sure that works
But i really do feel like I have that so maybe were good
What I guess i need to figure out though, is do we have to couple sign in to other logic, like hitting the backend for data
If we did want to do that, I would need some kind of thing where we're "signing in" but i dont think i have that
So i guess do we just set that based on other stuff, i feel like whats gonna happen is its all gonna be more "implict" than this

Here is an idea, what if i made a var about user auth state existing and being valid? but idk, i guess im worried about that? but maybe that ends up being more clear?

Ok so now, I want to get data about the user and what we need to do for them to "use" the site. Here are some things im thinking of.
What if this is a user's first time on our site, and we don't have any kind of row for them in the database. That would be something we would want to handle.
They might also have a row, and we could want to just get the data about them for our site. We'll want all the data about them like if they've authed with streamlabs. And their name and pubkey and minimum and any other data.

Good thing is all requests we make to the server should pass in these auth objects. And when they are "logged in" thats what we would need to finally make the first call. So we can have this call handle the creation of their account if needed.

And then it should just return the same data either way depending on what we get. That should give us some inital data to present. 

Then that would really take care of page load and frontend to backend auth model. And then we could just have to make the other apis usable again.

I guess i have to make a decision on how we get this inital data about the user? But that is something that I guess would just run once. But I'm worried with all the 

Almost got there but lost it. So were gonna need to do something to get this data initially. I'm guessing we could update based on things like user signed in or all the data that its made by.

Then we can have that effect get called often but only run when we're not "set up" yet.

We just really need that inital set up. Or we could have something in a use effect that just runs more implictly?

Or we could just run it explicitly.

We do need to know that there has been a "connection" made to the server. So we should request some kind of user state. I guess we could do something that would only run if the thing is null 

The explict version of this would call it all seperatly but i kinda hate that. So lets make a streamer state object i guess and if its null and the user is signed in then we can make a call. 

Ok i have some of the buttons and stuff in there, gotta get the rest of it ( if  anything, idr ) and then ill go to making the requests def work if they dont already and then ill go to the streamlabs part

ok so we have the buttons, lets get these button api calls into a more done state with the toasts and stuff so we can move past this and do the authorize stuff

ok we have the authed apis working which is really fucking cool, now we gotta do some stuff to make it look better like the spinners and shit when its updating and disabling stuff but to keep more core to functionality i wana get the streamlabs auth working again

for that i gotta design that flow where we gotta use the auth token to then get a new token that can then be used to update the value, it really is kinda that simple though i think, i can probably just take the value we have, hash it with maybe the time or a random value to create a "one use", pass that as the state, and double check it on the callback

this then means i either need an api that returns this value or an api that does the redirect, idk which is better i guess?

we kinda have this cooking, we def need to
1. make sure were actually handling bad states
2. are actually generating the code and add it to the database

some of the code was def a lil hacky so i just want to make sure were really using an acurate state



to use the real state, we def need to be adding and checking it in the database, so i can first make sure im generating it and then using it


to also handle bad state, i want to make sure for some of the redirect things im redirecting back to a screen where we can at least recover

ok now im making real hashes, lets now check the hash

ok i'm kinda ok with how the access token stuff works now

now lets just make sure were not totally failing on the error stuff end to end and we should be okay

we also have to actually make sure were gettinga correct verify with a siws


ok now we gotta

1. do verify for siws
2. handle button states for different auth and data states

ok so the next thing to do that makes sense is handle things like bad auth response and do things like make the user sign back in or something

if you had a bad auth you'd probably want that

that would also get me towards a consistant way to handle this stuff

so a few opportunties

2. handle different bad auth responses cause a user to log out basically
  - things like 500 codes probably wouldnt log you out though
3. handle general auth checking and respons could probably be consolidated
4. kinda seperate but with these new methods we also need to make sure were handling all the correct values and inputs for those on the F.E. too